"01"; "APIs are a common way to access data in different source systems like CRMs, ERPs, open data and many other systems." 
"02"; "API security could include different access methods, one of them is adding a signature in your API request in order to verify the user's authenticity."
"03"; "In this demo we are going to use the Binance API again, where some endpoints are secured not only with the API key but also require a signature."
"04"; "In particular let’s use the Fiat endpoints, which require HMAC Signing."
"05"; "Signed endpoints require a signature parameter. You need to use your API secret, key and all other parameters to create your signature. "
"06"; "Apart from that you need to provide a timestamp in milliseconds when the request is created and sent. "
"07"; "An additional parameter could be used to determine how long a request is valid. "
"08"; "This can be useful if you need to preprocess something between your signature calculation  and send the request."
"09"; "Now let’s head to our synapse workspace and create a new notebook."
"10"; "Change its name if you want."
"11"; "First we are going to import some libraries to work with HMAC, calculate hash values, time calculations and perform requests."
"12"; "Let’s run the notebook in advance to save some time."
"13"; "We are going to define a RECV Window value of 3 seconds."
"14"; "Get the current time."
"15"; "And convert it to milliseconds."
"16"; "Let's print something just to check our progress."
"17"; "Now let’s read the API secret from a key vault."
"18"; "We need the name of the key vault and the name of the secret."
"19"; "We can concatenate all request parameters in a variable."
"20"; "I include the RECV Window"
"21"; "Also the timestamp, which is mandatory"
"22"; "The transaction type"
"23"; "And the beginning time to scope the request to transactions from the beginning of 2022."
"24"; "We must encode the request before hashing it." 
"25"; "We can print the variables to check our progress."
"26"; "Now we are ready to define our signature."
"27"; "Secret secret is a bad name, sorry."
"28"; "Let’s create a new HMAC object and encode the API secret too."
"29"; "SHA 256 is required."
"30"; "We need the alphanumeric message, which is the digest."
"31"; "Let’s define the base URL in a variable."
"32"; "And for the resource, let’s use the fiat payments instead." 
"33"; "Transaction type zero means buy."
"34"; "All other parameters stay the same."
"35"; "Now we can define the request uri."
"36"; "Oooops, we have a typo." 
"37"; "Now we can see how the request URL looks like."
"38"; "To continue we need the headers, which must include the API key in a header parameter called X-MBX-APIKEY."
"39"; "Now is time to create the request."
"40"; "We can verify the status code and do some simple error handling." 
"41"; "As you can see, we got at least a couple of orders." 
"42"; "We can create a data frame out of the response."
"43"; "For that convert the response to JSON and read the data element, which is an array of buy orders." 
"44"; "Then get the column names in a list."
"45"; "The rows also as a list of rows."
"46"; "Finally we are ready to create the data frame."
"47"; "We can display it to verify our results."
"48"; "We can see 2 transactions where I bought USDT and Bitcoins using Euro and my credit card." 
"49"; "It’s time to persist the incoming data in a delta table."
"50"; "For that you need the URL of the storage location."
"51"; "Specifically the ABFSS path."
"52"; "Let’s call the table fiat underscore buy."
"53"; "Write the data frame with delta format."
"54"; "Let’s check that it was created."
"55"; "Finally, let’s create a table in the lake databases."
"56"; "We can use one existing database."
"57"; "The path is the same we used above."
"58"; "Verify the newly created table is working."
"59"; "Note the nice delta icon in the table." 
"60"; "Just use a simple query." 
"61"; "And this is the end of this exercise, I hope you enjoyed it." 